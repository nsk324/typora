# 190802 List

## 1. 알고리즘

#### 1.  유래

​	무하마드 알 콰리즈미라는 수학자의 이름에서 따왔다 (tmi)

#### 2. 정의

​	문제를 해결하기 위한 절차 

#### 3. 컴퓨터에서 알고리즘 표현하는 방법

1. 슈더코드 2. 순서도(flow chart)

#### 4.프로그래밍 할 때

1. 요구사항 분석 
2. 설계
3. 구현
4. 테스트
5. 유지보수

문제 잘읽어라 생각하고 코딩해라



#### 5. 알고리즘 측정법

- 시간복잡도 : 실제 걸리는 시간 계산 or 실행되는 명령문 개수 계산

- **빅-오 표기법(big-oh notation)**

  - n에 대한 항만을 표시
  - ex) O(3n+2) = O(n), O(2n^2+10n)=O(n^2), O(4)=O(1)
  - n개 데이터 입력 후 저장, 각 데이터 1씩 증가 후 화면 출력 복잡도? 
    - for 문 하나니까 O(n)이라고 볼수있다. 겹침도 없으니까 개꿀이다. 겹쳐지면 O(n^2)

- 추가
  P(다항식)

  - 이진탐색법? -> O(logn) but, 순서대로 정렬 되어있어야 한다.

  - 순차탐색법? -> O(n)

  - 선택, 버블,삽입 -> O(n^2)

  - Quick,병합,heap ->O(nlogn)

    <hr>

    NP 비결정적다항식

  - 부분집합 -> O(2^n)

  - 순열 -> O(n!)



## 2. 배열

#### 1. 정의

- 같은 자료형의 변수를 하나의 이름으로 사용하는 자료구조

#### 되도록 library 쓰지 말고 해보자

#### 1) 레고 떨어지는 게임 (for문 2개 필요)

#### 2)복원추출 게임 





#### 2. **완전검색(Brute-force)** :

 모든 경우의수를 나열해보고 확인하는 기법

​	자격검정 평가 (A)등에서 주어진 문제 풀때 완전검색으로 해답 낸 후 다른 알고리즘 사용하고 해답을 확인하는것이 바람직

1 . 순열로 모든 경우의 수 나열하기! 

#### i) 순열

- 서로 다른 것 중 뽑아서 한줄로 나열

- nPr

  <단순 순열 생성법, {1,2,3}> 동일한 숫자 없을때,..

  ```python
  for i1 in range(1,4):
      for i2 in range(1,4):
          if i2 != i1:
              for i3 in raneg(1,4):
                  if i3 != i1 and i3 != i2 :
                       print(i1, i2, i3)
  ```

  



재귀함수 쓰는 이유 : 가지치기 하려고



#### 3. 탐욕 알고리즘 

최적해를 구하는 데 사용되는 근시안적 방법

지역적으로 최적이긴 하지만 그게 문제의 최적이라는 보장은 x



#### 	1) 거스름돈 줄이기

​	-현재 고를 수 있는 가장 단위 큰 동전

​	-액수 초과하는가?? > 초과한다면 마지막 추가한 동전 뺴기 그리고 한단계 작은 동전 추가

​	-일치하면 끝이고 부족하면 추가



문제점, 만약 400원자리가 잇을대, 500 300 함.. 400 400 줘야하는데../..

#### 	2)bab-gin

- 만약 44345

- 숫자 갯수를 셉니다. ( run 조사후 run 완전 삭제)

  or

- triplet 조사 후 triplet 데이터 완전 삭제

- break 는 반복문 하나 빠져나가는거 continue는 뒤에꺼 없이 바로 다시 반복문 돌림

  ```1
  num = 456789
  c = [0] * 12
  # 실제 사용은 0-9지만 밑에 +2 때문에 range 초과할까봐
  
  for i in range(6):
  	c[num % 10] += 1
      num //= 10
      
  i = 0
  tri = run = 0
  while i < 10 :
      if c[i] >= 3 : #triple 조사 후 데이터 삭제
          c[i] -= 3
          tri += 1
          continue;
  	if c[i] >= 1 and c[i+1] >= 1 amd c[i+2] >=1: # run 조사 후 삭제
          c[i] -= 1
          c[i+1] -= 1
          c[i+2] -=1
          run += 1
          continue
      i += 1
  if run + tri == 2: print("baby gin")
  else : print("Lose")
  ```

- 오답 : 정렬한 후 3자리씩 끊으서 확인하면 안된다.



## 정렬

a등급까진 .sort 하면되긴하다 

#### 1. 종류

버블/ 카운팅/ 선택/ 퀵/ 삽입/ 병합



#### 2. 버블정렬

-방울이 제일 큰 게 물에 떠오르는것처럼 가장 큰 수가 뒤로 오게됨

-인접한 두 개의 원소를 비교하며 자리를 계속 교환

-O(n^2)

- n개 1회 pass : n-1회 n-2회 n-3회 .. 이렇게 총 n-1 번

```python
def BubbleSort(a) : #정렬할 List
    for i in range( len(a)-1, 0, -1): #n-1~1
        for j in range(0,i):
            if a[j] > a[a+1]:
                a[j], a[j+1] = a[j+1], a[j]
```

list는 참조 변수 a 지역변수, 원본을 참조하는 것이다.

#### 3.  카운팅정렬> 숫자만 가능

-항목의 순서를 결정하기위해 각 항목이 몇 개씩 있는지 세는작업을하여 선형시간에 정렬하는 효율적 알고리즘

-결과값을 나타낼수있는 list가 필요하게됩니다.

-뒤에서부터 결과list에 

-O(n)

> ascii (7bit)
>
> 0-126
>
> A 65 a 67

> bit 0 1 

> bite 8bit , abcd 다 구분하기위해서
>
> 7bit : ascii, parity bit는 에러체크하기위해 1 바이트를 비워놓습니다. 

```python
 def CountingSort(A,B,k):
    #A[1..n] 입력리스트 사용된 숫자
    #B[1..n] 정렬된  텍스트
    #C[1..k] 카운트 리스트
    C = [0] * k
    for i in range(0, len(B)):
        C[A[i]] += 1

    for i in range(1, len(C)):
        C[i] += C[i-1]

    for i in range(len(B)-1, -1, -1):
        B[C[A[i]]-1] = A[i]
        C[A[i]] -= 1


a = [0,4,1,3,1,2,4,1]
b = [0] * len(a)
CountingSort(a, b, 5)
print(b)
```

